"""*** ДОКУМЕНТАЦИЯ МОДУЛЯ CSVPROSTO***
Модуль csvprosto предназначен для анализа и работы с файлами *.csv.
Он позволяет делать выборку по различным параметрам, выводить результат на экран или сохранять его в файл.

КЛАСС FILE
При создании объекта Вы можете указать следующие параметры:
            [path]      - (обязательный) путь к файлу.
            [head]      - шапка таблицы:
                          1 - значение по умолчанию, в качестве шапки берётся первая строка файла.
                          0 - без шапки.
                          Задать свою шапку в не зависимости от значения параметра можно после создания объекта командой:
                          имя_объекта.header = (перечень наименований для столбцов)
                          Например: myfile.header = ("ID", "ФИО", "Логин", "Кабинет", "Примечание")
            [separator] - разделитель столбцов, по умолчанию равен ";".
            [encoding]  - кодировка файла, по умолчанию равна "UTF-8".

МЕТОДЫ КЛАССА FILE
Нумерация строк таблицы начинается сразу после шапки, или в случае её отсутствия с первой строки файла.
Нумерация колонок в параметрах начинается с 1.

.info()     - вывод основной информации по файлу.

.request()  - запрос к файлу *.csv для получения из него данных.
            Содержит следующие параметры:
            [lines] - (необязательный) задаётся диапазон строк для вывода.
                      Например: "5:27" - вывести строки с 5 по 27 включительно.
                      По умолчанию параметр равен пустой строке - "", что означает вывести все строки.

            [filter] - (необязательный) позволяет отфильтровать таблицу по параметрам.
                       Например: {1: "Видеокарта", 9: "128 Gb"} - сначала отфильтрует строки по первому столбцу,
                       которые содержат слово "Видеокарта", затем полученный результат снова отфильтрует по девятому
                       столбцу, где содержится текст "128 Gb".
                       Если заданы строки в параметре [lines], то фильтр будет только в пределах заданного диапазона.
                       По умолчанию параметр равен пустому словарю - {}, что означает отсутствие фильтра.

            [column] - (необязательный) позволяет задать колонки для отображения данных.
                       Например: (1, 5, 3) - выведет только колонки 1, 3 и 5, в том порядке в котором они будут
                       указаны в параметре.
                       Отображаемые колонки не влияют на параметр [filter].
                       По умолчанию параметр равен пустому кортежу - (), что означает показать все колонки.

            [header] - (необязательный) позволяет задать особую шапку для таблицы, в не зависимости есть она в ней
                       изначально или нет.
                       Например: ("Артикул", "Группа товаров", "Цена") - в выводе покажет шапку с заданными названиями
                       столбцов.
                       ВАЖНО: количество столбцов в шапке должно совпадать с количеством столбцов в параметре [column].
                       По умолчанию параметр равен пустому кортежу - (), что означает вывод заданной шапки по умолчанию.

            [sorting] - (необязательный) позволяет задать сортировку по одному столбцу. Например: "2:АЯ" - сделает
                        сортировку по второму столбцу по возрастанию (ЯА - по убыванию).
                        ВАЖНО: данный параметр зависит от параметра [column]. Например, если [column] задан, как
                        (1, 5, 3), то сортировка по условию "2:АЯ" будет сделана по 5 столбцу по возрастанию, так как
                        он является вторым столбцом в данной выборке.

.countvalues()  - подсчитывает количество одинаковых значений в столбцах.
                  Содержит следующие параметры:
                  [data]    - (необязательный) таблица с данными для вывода и шапка таблицы. По умолчанию обрабатывает
                            весь файл. Сюда можно передать данные сформированные с помощью метода .request()
                  [column]  - (необязательный) позволяет задать колонки в которых будут подсчитываться значения.
                              Например: (1, 5, 3) - будут посчитаны данные в колонках 1, 5 и 3.

.output()   - выводит данные на экран или в файл, принимает на вход кортеж с данными и шапкой. По умолчанию выводит
              данные в терминал.
              Содержит следующие параметры:
              [data] - (обязательный) таблица с данными для вывода и шапка таблицы.
                       Например: ([('012345', 'Видеокарта'), ('987654', 'Роутер')], ('Артикул', 'Группа товаров')), где
                       [('012345', 'Видеокарта'), ('987654', 'Роутер')] - данные для вывода таблицы,
                       ('Артикул', 'Группа товаров') - шапка таблицы.
              [num]  - (необязательный) позволяет добавить столбец с нумерацией строк (по умолчанию = False).
              [file] - (необязательный) вывод данных не в терминал, а в файл *.csv.
                       Например: "Новая таблица" - сохранит вывод данных в файл с указанным названием.
                       Расширение указывать не надо, оно присваивается автоматически *.csv.
                       По умолчанию параметр равен пустой строке - "", что означает вывести данные в терминал.
"""

class File:
    def __init__(self, path, head=1, separator=';', encoding='UTF-8'):
        self.path = path  # имя файла
        self.head = head  # наличие заголовка в файле
        self.encoding = encoding

        with open(self.path, 'r', encoding=encoding) as file:
            # из списка строк удаляем пробелы и '\n'
            self.csv = [line.strip().split(separator) for line in file.readlines()]

        self.strings = len(self.csv)  # количество строк в файле
        self.columns = len(self.csv[0])  # количество столбцов

        if self.head == 1:  # если заголовок есть, ТО
            self.header = self.csv[0]  # ... установить заголовок таблицы (по умолчанию 1 строка файла)
        elif self.head == 0:  # ... иначе, если заголовка нет, ТО
            self.header = ()  # ... установить пустой заголовок таблицы

        # self.csvd = {}  # словарь с данными столбцов
        # for col in range(self.columns):
        #     # перебираем каждую строчку и сохраняем данные в словарь по столбикам
        #     self.csvd[col+1] = [self.csv[i][col] for i in range(self.head, self.strings)]

        self.dt = []  # список с типами данных
        self.__datatypes(self.csv)  # вызов функции для определения данных в таблице (числа, строки)

    # ОПРЕДЕЛЯЕМ ТИП ДАННЫХ В СТОЛБЦАХ
    def __datatypes(self, data):
        first = None

        if self.head == 1:
            first = 1  # начать со второй строки файла
        elif self.head == 0:
            first = 0  # начать с первой строки файла

        for col in range(self.columns):  # перебираем данные в столбцах
            # перебираем каждый столбец в отдельности и определяем тим данных в нём (число, строка)
            self.dt.append(list({"числа" if data[var][col].replace('.', '').isdigit() else "строки"
                                 for var in range(first, self.strings)}))

    # ОБЩАЯ ИНФОРМАЦИЯ О ФАЙЛЕ
    def info(self):
        print(F"Файл:\t\t{self.path}")
        print(F"Строк:\t\t{self.strings}")
        print(F"Столбцов:\t{self.columns}")

        print(F"Шапка:", end="")
        if self.header:
            for i in enumerate(self.header, 1):  # номеруем столбцы начиная с 1
                if i[0] == 1:
                    # выводим имя столбца и тип данных в нём
                    print(F"\t\t{i[0]}) {i[1]} {self.dt[i[0]-1]}")
                else:
                    # выводим имя столбца и тип данных в нём
                    print(F"\t\t\t{i[0]}) {i[1]} {self.dt[i[0]-1]}")
        else:
            for i in range(self.columns):  # номеруем столбцы начиная с 1
                if i == 0:
                    # выводим имя столбца и тип данных в нём
                    print(F"\t\t{i+1}) нет {self.dt[i]}")
                else:
                    # выводим имя столбца и тип данных в нём
                    print(F"\t\t\t{i+1}) нет {self.dt[i]}")

    # ВЫБОРКА ДАННЫХ ИЗ ФАЙЛА, СОГЛАСНО ЗАПРОСУ
    def request(self, lines="", filter={}, column=(), header=[], sorting=""):
        resources = []  # список строк для вывода
        tempres = []  # временный список для отфильтрованных строк
        header = header  # голова таблицы

        # формируем список строк для вывода на экран
        if lines == "":  # если необходимо вывести весь файл, ТО
            if self.head == 1:  # если заголовок есть, ТО
                # ... взять файл без учёта заголовка
                resources = [self.csv[h] for h in range(1, len(self.csv))]
            elif self.head == 0:  # ... иначе, если заголовка нет, ТО
                resources = self.csv  # ... взять весь файл
        else:  # ... иначе добавляем нужные строки
            num_str = lines.split(':')  # получаем список с диапазоном строк
            for i in range(len(self.csv)):  # перебор списка строк
                if self.head == 1:  # если есть заголовок, ТО
                    if i in range(int(num_str[0]), int(num_str[1]) + 1):  # если счётчик содержится в диапазоне, ТО
                        resources.append(self.csv[i])  # ...добавить элемент
                elif self.head == 0:  # если заголовка нет (первой строкой будет нулевая), ТО
                    if i in range(int(num_str[0])-1, int(num_str[1])):  # если счётчик содержится в диапазоне, ТО
                        resources.append(self.csv[i])  # ...добавить элемент

        # фильтруем данные
        if filter:  # если задан фильтр, ТО
            for key in filter:  # перебираем ключи
                for line in range(len(resources)):  # перебираем список со строками данных
                    if resources[line][key-1].find(filter[key]) != -1:  # если строка найдена, ТО
                        tempres.append(resources[line])  # ... добавляем эту строку во временный список
                resources = tempres  # сохраняем новые данные
                tempres = []  # очищаем временный список

        # делаем отбор колонок и задаём для них шапку
        if column:  # если заданы колонки, ТО
            resources = [[string[col - 1] for col in column] for string in resources]
            if not header and self.header:  # если НЕ задан особый заголовок и есть базовый заголовок, ТО
                header = [self.header[col - 1] for col in column]
        else:  # иначе
            header = self.header  # берём все столбцы для заголовка

        # сортировка данных
        if sorting:  # если задана сортировка столбика, ТО
            sort = sorting.split(':')  # получаем список с условиями сортировки (столбец:порядок сортировки)
            if sort[1] == "АЯ":
                # сортируем список по выбранному столбцу по возрастанию
                resources.sort(key=lambda s: s[int(sort[0])-1])
            elif sort[1] == "ЯА":
                # сортируем список по выбранному столбцу по убыванию
                resources.sort(key=lambda s: s[int(sort[0])-1], reverse=True)

        return resources, header

    # ПОДСЧЁТ ЗНАЧЕНИЙ
    def countvalues(self, data=[], column=()):
        all_list = []  # список для всех значений
        uniq_list = []  # список для отбора уникальных значений
        data = list(data)  # преобразуем кортеж в список для данных сформированных в функции request()

        if not data:  # если данные не указаны, ТО
            if self.head == 1:  # если заголовок есть, ТО
                # ... взять файл без учёта заголовка
                data.append([self.csv[h] for h in range(1, len(self.csv))])
            elif self.head == 0:  # ... иначе, если заголовка нет, ТО
                data.append(self.csv)  # ... взять весь файл
            data.append(self.header)  # добавляем шапку

        if column:  # если заданы колонки, ТО
            # формируем данные для таблицы
            data[0] = [[string[col - 1] for col in column] for string in data[0]]
            # формируем шапку
            if data[1]:  # если задана шапка, ТО
                data[1] = [data[1][col - 1] for col in column]
            elif not data[1] and self.header:  # если НЕ задан особый заголовок и есть базовый заголовок, ТО
                data[1] = [self.header[col - 1] for col in column]

        for i in range(len(data[1])):  # выполняем цикл по количеству колонок
            all_list.append([val[i] for val in data[0]])  # формируем список со списком всех значений
            uniq_list.append(list({val[i] for val in data[0]}))  # формируем список со списком уникальных значений

        # подсчитываем количество повторений
        for i in range(len(data[1])):  # выполняем цикл по количеству колонок
            for uniq in range(len(uniq_list[i])):  # перебираем значения
                # записываем в список уникальных значений количество этих значений
                uniq_list[i][uniq] = F"[{all_list[i].count(uniq_list[i][uniq])}] - {uniq_list[i][uniq]}"
            # сортируем список на основе части строки
            uniq_list[i].sort(key=lambda x: int(x.split()[0][1:-1]), reverse=True)

        # получаем максимальное количество уникальных элементов для нужного количества строк в таблице
        max_val = max([len(i) for i in uniq_list])

        # формируем данные для вывода
        for col in range(len(data[1])):  # выполняем цикл по количеству колонок
            for row in range(len(data[0])):  # выполняем цикл по количеству строк
                # если номер строки меньше количеству элементов в списке уникальных значений, ТО
                if row < len(uniq_list[col]):
                    # сохраняем в текущей строке в нужной колонке новое значение
                    data[0][row][col] = uniq_list[col][row]
                else:  # иначе заполняем данные пустыми строками
                    data[0][row][col] = ""

        # удаляем списки с пустыми строками
        for i in range(len(data[0])-1, max_val-1, -1):  # выполняем цикл по максимальному количеству элементов
            del data[0][i]  # удаляем строку с конца и до максимального количества элементов

        return data

    # ФОРМИРОВАНИЕ РЕЗУЛЬТАТА ДЛЯ ОТОБРАЖЕНИЯ НА ЭКРАНЕ
    def output(self, data, num=False, file=""):  # data - это кортеж с данными (данные, шапка)
        # добавить столбик с нумерацией строк
        if num:
            for i in range(len(data[0])):
                data[0][i].insert(0, str(i+1))  # добавляем столбик с номерами строк
            data[1].insert(0, "№ п/п")  # добавляем в шапку название столбца

        if file:  # вывод в файл csv
            with open(file + '.csv', 'w', encoding=self.encoding) as csvfile:
                print(*data[1], sep=";", file=csvfile)  # сохраняем заголовок
                for i in data[0]:
                    print(*i, sep=";", file=csvfile)  # сохраняем таблицу с данными
        else:  # вывод на экран
            columns = len(data[0][0])  # количество колонок
            width = [0] * columns  # список с шириной колонок

            # получаем ширину столбцов исходя из длины текста в них
            for line in data[0]:  # перебор списка со строками
                for w in range(columns):  # перебор элементов из списка элементов строк
                    if len(line[w]) > width[w]:  # если длина элемента больше заданного, ТО
                        width[w] = len(line[w])  # ...сохранить новую ширину
            if data[1]:  # если есть заголовок, ТО проверяем его ширину
                for w in range(columns):  # перебор элементов из списка элементов строк
                    if len(str(data[1][w])) > width[w]:  # если длина элемента больше заданного, ТО
                        width[w] = len(str(data[1][w]))  # ...сохранить новую ширину

            # преобразуем словарь width в строку разделитель для таблицы
            split = "".join(list(map(lambda x: "+" + "-" * (x+2), width))) + "+"

            # преобразуем числа в словаре width в строки для форматированного вывода данных
            output = "| {:" + "} | {:".join(list(map(str, width))) + "} |"

            # вывод данных
            print(split)
            if data[1]:  # если есть заголовок, ТО
                print(output.format(*data[1]))  # выводим заголовок
                print(split)  # выводим дополнительный разделитель
            for i in data[0]:  # вывод данных в виде таблицы
                print(output.format(*i))
            print(split)
